

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>UGW Tutorial &#8212; SCOOTR</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'UGW_tutorial';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="UCOOT Tutorial" href="UCOOT_tutorial.html" />
    <link rel="prev" title="Setup Tutorial" href="setup_tutorial.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="intro.html">
  
  
  
  
    
    
      
    
    
    <img src="_static/SCOOTR_logo.006.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="_static/SCOOTR_logo.006.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="intro.html">
                    Welcome to SCOOTR
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Core Tutorials</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="installation_instructions.html">Getting Set Up</a></li>
<li class="toctree-l1"><a class="reference internal" href="theory.html">The Evolution of SCOOTR</a></li>
<li class="toctree-l1"><a class="reference internal" href="setup_tutorial.html">Setup Tutorial</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">UGW Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="UCOOT_tutorial.html">UCOOT Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="fused_tutorial.html">Fused Formulation Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="SCOOTR_tutorial.html">SCOOTR Tutorial</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/Cbaker37/SCOOTR.git" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/Cbaker37/SCOOTR.git/issues/new?title=Issue%20on%20page%20%2FUGW_tutorial.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/UGW_tutorial.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>UGW Tutorial</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#data-download">Data download</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#preprocessing">Preprocessing</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#converting-datasets-to-distance-matrices">Converting Datasets to Distance Matrices</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#default-ugw">Default UGW</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#entropic-regularization">Entropic Regularization</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#marginal-relaxation">Marginal Relaxation</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#conclusion">Conclusion</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="ugw-tutorial">
<h1>UGW Tutorial<a class="headerlink" href="#ugw-tutorial" title="Permalink to this heading">#</a></h1>
<p>In this tutorial, we will examine how to use Gromov-Wasserstein (GW) and unbalanced Gromov-Wasserstein (UGW) to align a CITEseq dataset, which has co-assayed antibody and gene expression data on 7985 human/mouse blood cells. We select 1000 human samples from this dataset, and split the data into two matrices: one that contains antibody information on these samples and another that contains gene expression information on the same samples. The goal in this tutorial (as well as UCOOT) will be to recover which sample matches with which sample using optimal transport. So, we are trying to recover a 1-1 mapping that we know exists.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Before beginning this tutorial, note that it serves more as an introduction to UCOOT by showing a specific application (UGW), as well as setting up intuition for SCOOTR later on. UCOOT is a generalized version of UGW, and UGW can be directly recovered by making the right choices for the inputs to UCOOT. So, if you want a more detailed tutorial of the generalized version, go to the UCOOT tutorial. This tutorial goes into a little bit more detail on the specifics of each hyperparameter, but leaves some of the potential steps to the UCOOT tutorial.</p>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>If you have not yet configured a SCOOTR directory of some kind, see our installation instructions markdown. Once you complete those steps or set up your own virual environment, continue on here.</p>
<p>If you aren’t sure what any of the parameters for setting up a SCOOTR object mean, try our setup tutorial for getting used to using the tool. We use the default parameters for this tutorial.</p>
<p>If you are unsure what some of the notation means throughout the rest of this document, try reading our optimal transport theory section to get more comfortable.</p>
<p>If you are already comfortable with UGW, try moving on to our UCOOT tutorial.</p>
</div>
<section id="data-download">
<h2>Data download<a class="headerlink" href="#data-download" title="Permalink to this heading">#</a></h2>
<p>If you wish to work with the raw PBMC_ADT and PBMC_RNA files from the CITE-seq dataset (we will use the mostly preprocessed ones), run the following commands in the terminal in the root directory of this tutorial repository:</p>
<center> sh ./download_scripts/CITEseq_download.sh </center><p>If you download the code manually instead, make sure to produce the same file structure - i.e., there should be a data directory with a CITEseq subdirectory containing your csv files. This folder should already be populated with our two preprocessed datasets.</p>
</section>
<section id="preprocessing">
<h2>Preprocessing<a class="headerlink" href="#preprocessing" title="Permalink to this heading">#</a></h2>
<p>We will start with some mild preprocessing, such as loading the preprocessed datasets into variables local to this notebook. We begin by setting up pytorch. Use this as is, unless you would like to try a different device.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">torch</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Torch version: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">__version__</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;CUDA available: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">()))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;CUDA version: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">version</span><span class="o">.</span><span class="n">cuda</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;CUDNN version: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">cudnn</span><span class="o">.</span><span class="n">version</span><span class="p">()))</span>

<span class="n">use_cuda</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">()</span>
<span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cuda:0&quot;</span> <span class="k">if</span> <span class="n">use_cuda</span> <span class="k">else</span> <span class="s2">&quot;cpu&quot;</span><span class="p">)</span>
<span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">cudnn</span><span class="o">.</span><span class="n">benchmark</span><span class="o">=</span><span class="kc">True</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Torch version: 2.0.1
CUDA available: False
CUDA version: None
CUDNN version: None
</pre></div>
</div>
</div>
</div>
<p>In these tutorials, we omit the exact preprocessing steps for this dataset. However, if you would like to replicate the steps in the appendix of Tran et al., implement your preprocessing of the raw datasets here. Use the shape attribute for ndarrays/dataframes/anndata to get a sense for how large these datasets are.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%capture</span>
<span class="kn">import</span> <span class="nn">src.scootr</span> <span class="k">as</span> <span class="nn">scoot</span>
<span class="kn">import</span> <span class="nn">scanpy</span> <span class="k">as</span> <span class="nn">sc</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">import</span> <span class="nn">umap</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">normalize</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;font.family&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Helvetica Neue&#39;</span>

<span class="n">X_raw</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s2">&quot;./data/CITEseq/citeseq_adt_normalized_1000cells.csv&quot;</span><span class="p">)</span>
<span class="n">y_raw</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s2">&quot;./data/CITEseq/citeseq_rna_normalizedFC_1000cells.csv&quot;</span><span class="p">)</span>
<span class="n">x_feat_labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;CD11a&quot;</span><span class="p">,</span><span class="s2">&quot;CD11c&quot;</span><span class="p">,</span><span class="s2">&quot;CD123&quot;</span><span class="p">,</span><span class="s2">&quot;CD127-IL7Ra&quot;</span><span class="p">,</span><span class="s2">&quot;CD14&quot;</span><span class="p">,</span><span class="s2">&quot;CD16&quot;</span><span class="p">,</span><span class="s2">&quot;CD161&quot;</span><span class="p">,</span><span class="s2">&quot;CD19&quot;</span><span class="p">,</span><span class="s2">&quot;CD197-CCR7&quot;</span><span class="p">,</span><span class="s2">&quot;CD25&quot;</span><span class="p">,</span><span class="s2">&quot;CD27&quot;</span><span class="p">,</span><span class="s2">&quot;CD278-ICOS&quot;</span><span class="p">,</span><span class="s2">&quot;CD28&quot;</span><span class="p">,</span><span class="s2">&quot;CD3&quot;</span><span class="p">,</span><span class="s2">&quot;CD34&quot;</span><span class="p">,</span><span class="s2">&quot;CD38&quot;</span><span class="p">,</span><span class="s2">&quot;CD4&quot;</span><span class="p">,</span><span class="s2">&quot;CD45RA&quot;</span><span class="p">,</span><span class="s2">&quot;CD45RO&quot;</span><span class="p">,</span><span class="s2">&quot;CD56&quot;</span><span class="p">,</span><span class="s2">&quot;CD57&quot;</span><span class="p">,</span><span class="s2">&quot;CD69&quot;</span><span class="p">,</span><span class="s2">&quot;CD79b&quot;</span><span class="p">,</span><span class="s2">&quot;CD8a&quot;</span><span class="p">,</span><span class="s2">&quot;HLA.DR&quot;</span><span class="p">]</span>
<span class="n">y_feat_labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;ITGAL&quot;</span><span class="p">,</span><span class="s2">&quot;ITGAX&quot;</span><span class="p">,</span><span class="s2">&quot;IL3RA&quot;</span><span class="p">,</span><span class="s2">&quot;IL7R&quot;</span><span class="p">,</span><span class="s2">&quot;CD14&quot;</span><span class="p">,</span><span class="s2">&quot;FCGR3A&quot;</span><span class="p">,</span><span class="s2">&quot;KLRB1&quot;</span><span class="p">,</span><span class="s2">&quot;CD19&quot;</span><span class="p">,</span><span class="s2">&quot;CCR7&quot;</span><span class="p">,</span><span class="s2">&quot;IL2RA&quot;</span><span class="p">,</span><span class="s2">&quot;CD27&quot;</span><span class="p">,</span><span class="s2">&quot;ICOS&quot;</span><span class="p">,</span><span class="s2">&quot;CD28&quot;</span><span class="p">,</span><span class="s2">&quot;CD3E&quot;</span><span class="p">,</span><span class="s2">&quot;CD34&quot;</span><span class="p">,</span><span class="s2">&quot;CD38&quot;</span><span class="p">,</span><span class="s2">&quot;CD4&quot;</span><span class="p">,</span><span class="s2">&quot;PTPRC&quot;</span><span class="p">,</span><span class="s2">&quot;PTPRC&quot;</span><span class="p">,</span><span class="s2">&quot;NCAM1&quot;</span><span class="p">,</span><span class="s2">&quot;B3GAT1&quot;</span><span class="p">,</span><span class="s2">&quot;CD69&quot;</span><span class="p">,</span><span class="s2">&quot;CD79B&quot;</span><span class="p">,</span><span class="s2">&quot;CD8A&quot;</span><span class="p">,</span><span class="s2">&quot;HLA-DRA&quot;</span><span class="p">]</span> 
<span class="n">samp_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Cell </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X_raw</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
</pre></div>
</div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In order to examine further how exactly UGW alignment works later on in this tutorial, we examine a subset of 10 of the 25 gene-antibody pairs.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># l2 normalization of both datasets, which we found to help with single cell applications</span>
<span class="n">X_full_annotated</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">normalize</span><span class="p">(</span><span class="n">normalize</span><span class="p">(</span><span class="n">X_raw</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;l2&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;l2&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="n">X_full_annotated</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">X_full_annotated</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">samp_labels</span><span class="p">,</span> <span class="n">x_feat_labels</span>
<span class="n">y_full_annotated</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">normalize</span><span class="p">(</span><span class="n">y_raw</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;l2&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="n">y_full_annotated</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">y_full_annotated</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">samp_labels</span><span class="p">,</span> <span class="n">y_feat_labels</span>

<span class="n">X_full</span> <span class="o">=</span> <span class="n">X_full_annotated</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
<span class="n">y_full</span> <span class="o">=</span> <span class="n">y_full_annotated</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

<span class="n">X_annotated</span> <span class="o">=</span> <span class="n">X_full_annotated</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span>
<span class="n">y_annotated</span> <span class="o">=</span> <span class="n">y_full_annotated</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">X_annotated</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">y_annotated</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Now that we have our data, we visualize it with two dimensionality reduction techniques: UMAP and PCA. These visualization techniques can be helpful for visualizing any intermediate steps through this project, although our eventual coupling matrices are better visualized with a heatmap.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">um</span> <span class="o">=</span> <span class="n">umap</span><span class="o">.</span><span class="n">UMAP</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="n">originalX_um</span><span class="o">=</span><span class="n">um</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="n">originaly_um</span><span class="o">=</span><span class="n">um</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

<span class="c1">#Visualization of the global geometry</span>
<span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span><span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">originalX_um</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">originalX_um</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;ADT Domain </span><span class="se">\n</span><span class="s2"> before Alignment&quot;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">originaly_um</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">originaly_um</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Gene Expression Domain </span><span class="se">\n</span><span class="s2"> before Alignment&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/9976b46cdd636a2f8286ee128b902ce4ce053f8b50a91507d5f10da6da4eb3e0.png" src="_images/9976b46cdd636a2f8286ee128b902ce4ce053f8b50a91507d5f10da6da4eb3e0.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>

<span class="n">pca</span><span class="o">=</span><span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">originalX_pca</span><span class="o">=</span><span class="n">pca</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="n">originaly_pca</span><span class="o">=</span><span class="n">pca</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

<span class="c1">#Visualization of the global geometry</span>
<span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span><span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">originalX_pca</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">originalX_pca</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;ADT Domain </span><span class="se">\n</span><span class="s2"> Before Alignment&quot;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">originaly_pca</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">originaly_pca</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Gene Expression Domain </span><span class="se">\n</span><span class="s2"> Before Alignment&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/698944853dae34f736faf9a5bb0bffa10c81e7dc3e4f7af0ea7dfbe26bdf535a.png" src="_images/698944853dae34f736faf9a5bb0bffa10c81e7dc3e4f7af0ea7dfbe26bdf535a.png" />
</div>
</div>
</section>
<section id="converting-datasets-to-distance-matrices">
<h2>Converting Datasets to Distance Matrices<a class="headerlink" href="#converting-datasets-to-distance-matrices" title="Permalink to this heading">#</a></h2>
<p>In this tutorial, we will go over how to use a SCOOTR object to align your data using UGW. UGW is a simpler form of UCOOT, which seeks only to minimize the transport cost for samples, and ignores the problem of aligning features. We can begin by instantiating a SCOOTR object.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">scootr</span> <span class="o">=</span> <span class="n">scoot</span><span class="o">.</span><span class="n">SCOOTR</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>In the case of UGW, the goal is to generate one coupling matrix, matching samples from one domain to samples of the other. UGW treats the samples of each experiment as two probability distributions (one for each experiment) and finds the coupling matrix that determines the most cost-efficient way to move mass from one distribution to the other. So, UGW will produce a matrix that determines how much mass of a sample in one domain should go to each sample in the other domain (values seen across each sample’s respective row or column). This matrix is then used to project data from one domain into the other.</p>
<p>In order to do this, UGW seeks to minimize the cost of transporting each pair of points onto each other pair of points. In particular, for a given <span class="math notranslate nohighlight">\(x_a\)</span> and <span class="math notranslate nohighlight">\(x_b\)</span> in one domain and a given <span class="math notranslate nohighlight">\(y_a\)</span> and <span class="math notranslate nohighlight">\(y_b\)</span> in the other domain, UGW calculates the cost of transporting <span class="math notranslate nohighlight">\(x_a\)</span> and <span class="math notranslate nohighlight">\(x_b\)</span> to <span class="math notranslate nohighlight">\(y_a\)</span> and <span class="math notranslate nohighlight">\(y_b\)</span>: <span class="math notranslate nohighlight">\(L(D(x_a, x_b), D(y_a, y_b)) \cdot \pi_{x_a, y_a} \cdot \pi_{x_b, y_b}\)</span>, where <span class="math notranslate nohighlight">\(L\)</span> is a given cost function and <span class="math notranslate nohighlight">\(D\)</span> is some measure of intra-domain distance (in our case, l2 distance or nearest-neighbor connectivity). So, UGW seeks to select <span class="math notranslate nohighlight">\(\pi\)</span> to minimize these costs summed across all pairs of points in each domain. Looking at this cost function, we can see that UGW penalizes matching a pair of points based on some measure of the difference in pairwise distances; i.e., UGW seeks to maintain local geometry. As another way of thinking about it, UGW encourages a large <span class="math notranslate nohighlight">\(\pi_{xy}\)</span> if <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> have similar “locations” relative to the rest of their domain.</p>
<p>Looking at the cost function again, we can see that UGW requires us to know the distance between each pair of points resting in the same domain. In fact, we input these distance matrices to UGW in order to make our alignments. Let’s look at a few different ways we can calculate these distance matrices:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># l2 distance</span>
<span class="n">Dx_l2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="n">Dy_l2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

<span class="c1"># knn connectivity distance</span>
<span class="n">Dx_knn</span><span class="p">,</span> <span class="n">Dy_knn</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">scootr</span><span class="o">.</span><span class="n">knn_dist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">scootr</span><span class="o">.</span><span class="n">knn_dist</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="default-ugw">
<h2>Default UGW<a class="headerlink" href="#default-ugw" title="Permalink to this heading">#</a></h2>
<p>Now, we will start with an example of UGW using its default parameters, followed by a completed alignment. Note that, to complete an alignment, we must use the produced coupling matrix to project the samples in one domain into the other. Since we use euclidean distance to penalize the difference in pairwise distances (<span class="math notranslate nohighlight">\(L\)</span> function in the cost in the previous section), this projection, for a given <span class="math notranslate nohighlight">\(y_a\)</span> in the domain we are seeking to project, takes the row/column-wise (depending on the orientation of <span class="math notranslate nohighlight">\(\pi\)</span>) weighted average associated with <span class="math notranslate nohighlight">\(y_a\)</span>:</p>
<p><span class="math notranslate nohighlight">\(y_a\)</span> projected onto <span class="math notranslate nohighlight">\(X = \frac{\Sigma_{i=1}^{n_x}(x_i*\pi_{x_i,y_a})}{\Sigma_{i=1}^{n_x} (\pi_{x_i,y_a})}\)</span></p>
<p>Once this process is completed for all <span class="math notranslate nohighlight">\(y_j\)</span>, we recover UGW’s predicted values for the cells from domain <span class="math notranslate nohighlight">\(y\)</span> on the features of domain <span class="math notranslate nohighlight">\(X\)</span>. In a separately assayed example (not as trivial like this case), this alignment will give us the measurement for every feature in <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(y\)</span> on the sample set of <span class="math notranslate nohighlight">\(y\)</span> – we have the measured values on <span class="math notranslate nohighlight">\(y\)</span>’s features and the predicted values on <span class="math notranslate nohighlight">\(X\)</span>’s features. Let’s see this workflow in action (UGW followed by projection) using UGW’s default parameters (except for a change in <span class="math notranslate nohighlight">\(\epsilon\)</span>, which we will examine later). Then, we will move on to the two main hyperparameters for this method. Note that for now, we will stick to KNN distance.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># set verbose=True to get a breakdown of the cost progression during optimization</span>
<span class="c1"># set log=True to get extra return values, log_cost and log_ent_cost, which display the cost progression</span>
<span class="p">(</span><span class="n">pi_samp_1</span><span class="p">,</span> <span class="n">pi_samp_2</span><span class="p">),</span> <span class="n">duals</span><span class="p">,</span> <span class="n">log_cost</span><span class="p">,</span> <span class="n">log_ent_cost</span> <span class="o">=</span> <span class="n">scootr</span><span class="o">.</span><span class="n">solver_fgw</span><span class="p">(</span><span class="n">Dx_knn</span><span class="p">,</span> <span class="n">Dy_knn</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Cost at iteration 1: 0.03323853015899658
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Cost at iteration 6: 0.01691684126853943
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Cost at iteration 11: 0.01679953932762146
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Cost at iteration 16: 0.016788393259048462
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Cost at iteration 21: 0.01678478717803955
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Cost at iteration 26: 0.016783297061920166
</pre></div>
</div>
</div>
</div>
<p>In the above code, notice that we get back a lot more than just a singular coupling matrix. Since we solve for UGW using a generalized process that we also use to solve UCOOT (generates two coupling matrices), we end up with multiple coupling matrices; however, these coupling matrices should be very similar, considering the matrices we input to the process are symmetric across the diagonal. In other words, since our samples and features are the “same” with these distance matrices, our sample coupling matrix and feature coupling matrix should be similar, and both represent a sample coupling matrix (since we generated our distance matrices with sample data). This idea will make a little more sense once you reach the UCOOT tutorial. These two coupling matrices are pi_samp_1 and pi_samp_2 above.</p>
<p>Next, we also get back the duals. The duals relate to the optimization process we use to solve for the coupling matrices; in particular, they are a biproduct of the Sinkhorn algorithm, one of our methods for OT iteration. The way we solve for the coupling matrix involves iteratively running Sinkhorn (or another OT algorithm) on one of the coupling matrices, followed by doing the same on the other, as described in the setup tutorial. Sinkhorn iteratively solves for two duals, which, when multiplied (dual_1 * primal * dual_2) by a primal matrix that we initialize, recover the current coupling matrix being optimized. Since we switch between optimizing one coupling matrix and the other, we end up with 4 duals at the end of optimization. As a result, if you unpack the duals variable above, it is of the shape (_,_), (_,_).</p>
<p>The next two results we get are only present if we set log=True. If we were to set log=false, we would only have two values to unpack in the above code. However, if log=True, we also get back a log of the transport cost (log_cost) in addition to the log of the entropic + transport cost (log_ent_cost) as a list. We will go over entropic cost in the next subsection of this tutorial. For now, we move on to the application of these coupling matrices: alignment.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Be careful how you order your matrices between UGW and alignment. pi_samp will have the samples of the first matrix you input on its vertical axis and the samples of the second matrix you input on its horizontal axis. Our get_barycentre method takes in the anchor domain (the one you want to project onto) and assumes that the anchor domain samples are on the vertical axis during projection. Therefore, make sure to put your desired anchor domain first in the previous step. So, if we want to project y onto X, (as we are doing in this case), we put X before y above, and then pass in X to get_barycentre. We then get back our aligned y.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">aligned_y</span> <span class="o">=</span> <span class="n">scootr</span><span class="o">.</span><span class="n">get_barycentre</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">pi_samp_1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>From here, we can score the alignment. Note that we generated <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(y\)</span> such that they contain data on the same set of 1000 cells (co-assayed); this means that, in a perfect alignment, aligned_y would be identical to <span class="math notranslate nohighlight">\(X\)</span>. So, we can score aligned_y based on some measure of how close it is to <span class="math notranslate nohighlight">\(X\)</span>. To do this, we use FOSCTTM (fraction of samples closer than true match) as described in the UGW tutorial. In order to calculate a score, for each sample <span class="math notranslate nohighlight">\(x\)</span> in <span class="math notranslate nohighlight">\(X\)</span>, we compute a ranking of how close (l2 distance) each sample in aligned_y is to <span class="math notranslate nohighlight">\(x\)</span>. From here, we find the index at which the true match for <span class="math notranslate nohighlight">\(x\)</span> falls within this sorted ranking. This index tells us how many samples in aligned_y are closer to <span class="math notranslate nohighlight">\(x\)</span> than its true match, which is a measure of how well the alignment matched samples in y to <span class="math notranslate nohighlight">\(x\)</span>. By taking the average of these scores across all <span class="math notranslate nohighlight">\(x\)</span>, we can get a sense for how good the alignment was. The lower the FOSCTTM, the better.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In this tutorial, we are not going for perfect alignments; rather, we are trying to get some intuition for how the different parameters modify the alignment. As we learn better how to tune our hyperparameters throughout the course of this core chapter, the alignment scores will gradually improve.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fracs</span> <span class="o">=</span> <span class="n">scootr</span><span class="o">.</span><span class="n">calc_domainAveraged_FOSCTTM</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">aligned_y</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Average FOSCTTM score for this alignment with X onto Y is:&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">fracs</span><span class="p">))</span>
<span class="n">legend_label</span><span class="o">=</span><span class="s2">&quot;UGW alignment FOSCTTM </span><span class="se">\n</span><span class="s2"> average value: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">fracs</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fracs</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">fracs</span><span class="p">),</span> <span class="s2">&quot;b--&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">legend_label</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Cells&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Sorted FOSCTTM&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Average FOSCTTM score for this alignment with X onto Y is: 0.5619134134134134
</pre></div>
</div>
<img alt="_images/afcd474fbb0a1fdce947fbc74a50d55fffada42704ac367a014c133b8a442b0a.png" src="_images/afcd474fbb0a1fdce947fbc74a50d55fffada42704ac367a014c133b8a442b0a.png" />
</div>
</div>
<p>With the newly aligned data, we can now see how the alignment looks on UMAP and PCA:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Xy_um</span><span class="o">=</span><span class="n">um</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">aligned_y</span><span class="o">.</span><span class="n">numpy</span><span class="p">()),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

<span class="n">X_um</span><span class="o">=</span><span class="n">Xy_um</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1000</span><span class="p">,]</span>
<span class="n">y_um</span><span class="o">=</span><span class="n">Xy_um</span><span class="p">[</span><span class="mi">1000</span><span class="p">:,]</span>

<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X_um</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">X_um</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;ADT&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">y_um</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">y_um</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Gene Expression&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Colored based on domains&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/b799581fd812a465ed6bd9d31b9fb860da86b8a2a576abc432d0e66d695d6abb.png" src="_images/b799581fd812a465ed6bd9d31b9fb860da86b8a2a576abc432d0e66d695d6abb.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pca</span><span class="o">=</span><span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Xy_pca</span><span class="o">=</span><span class="n">pca</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">aligned_y</span><span class="o">.</span><span class="n">numpy</span><span class="p">()),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
<span class="n">X_pca</span><span class="o">=</span><span class="n">Xy_pca</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1000</span><span class="p">,]</span>
<span class="n">y_pca</span><span class="o">=</span><span class="n">Xy_pca</span><span class="p">[</span><span class="mi">1000</span><span class="p">:,]</span>

<span class="c1"># Plot aligned domains, samples colored by domain identity:</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X_pca</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">X_pca</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;ADT&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">y_pca</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">y_pca</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Gene Expression&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Colored based on domains&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/92bdc646b35ab347529919eb48a42b7b42fb9734c2ca670bdfe6ab6974b8d223.png" src="_images/92bdc646b35ab347529919eb48a42b7b42fb9734c2ca670bdfe6ab6974b8d223.png" />
</div>
</div>
<p>Note that the alignments look nice (the shapes match up well). This property does not guarantee a good alignment, as we can see by our high original FOSCTTM score. In fact, it is more a representation of the sparsity of the coupling matrix – if the coupling matrix is very sparse, it will get close to attempting a 1-1 matching, which could be wrong (even though it is 1-1). Having a coupling matrix that is too sparse can be quite dangerous in cases where there is no underlying 1-1 sample map.</p>
<p>From here, we can examine the coupling matrices themselves to see what they may tell us. Given that these sample matrices are large, rather than graphing them, we will look at the rough distance between the two matrices (total difference between cells):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Total sum of pi_samp_1: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">pi_samp_1</span><span class="p">)))))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Total sum of pi_samp_2: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">pi_samp_2</span><span class="p">)))))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Total sum of differences: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">pi_samp_1</span> <span class="o">-</span> <span class="n">pi_samp_2</span><span class="p">)))))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Total sum of pi_samp_1: 1.0000041723251343
Total sum of pi_samp_2: 1.0000029802322388
Total sum of differences: 0.014399499632418156
</pre></div>
</div>
</div>
</div>
<p>As we can see, the matrices are quite close; relative to their total size, they don’t differ much. If these matrices converged perfectly, we would see no difference, given the symmetry of the distance matrices we discussed above.</p>
</section>
<section id="entropic-regularization">
<h2>Entropic Regularization<a class="headerlink" href="#entropic-regularization" title="Permalink to this heading">#</a></h2>
<p>Now that we have one example done, let’s look at how entropic regularization and the <span class="math notranslate nohighlight">\(\epsilon\)</span> hyperparameter change the alignment process. In addition to the main part of the cost function as described in the previous section, UGW adds an extra cost term measuring the entropy of the coupling matrix multiplied by the hyperparameter <span class="math notranslate nohighlight">\(\epsilon\)</span>. This means that, for larger values of <span class="math notranslate nohighlight">\(\epsilon\)</span>, the coupling matrix will have more entropy, meaning it will be more dense (farther from a sparse alignment of samples). In addition, the larger <span class="math notranslate nohighlight">\(\epsilon\)</span> is, the faster Sinkhorn’s algorithm will converge and produce a cost-minimizing coupling matrix. Let’s see these effects in action:</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Entropic regularization does not apply to all OT algorithms we use to solve the inner components of a BCD iteration. Sinkhorn is an example of an algorithm that depends on entropic regularization, and a common one we use to speed up alignment. However, conditional gradient descent, earth mover’s distance, and majorization-minimization all do not require entropic regularization.</p>
<p>Although entropic regularization only really applies for the Sinkhorn algorithm, Sinkhorn is the most common method we use for OT iterations (to the point that the following section is warranted).</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">pi_samp_sm</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="n">_</span><span class="p">,</span> <span class="n">log_cost</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">scootr</span><span class="o">.</span><span class="n">solver_fgw</span><span class="p">(</span><span class="n">Dx_knn</span><span class="p">,</span> <span class="n">Dy_knn</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">log_cost</span><span class="p">))</span>

<span class="p">(</span><span class="n">pi_samp_med</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="n">_</span><span class="p">,</span> <span class="n">log_cost</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">scootr</span><span class="o">.</span><span class="n">solver_fgw</span><span class="p">(</span><span class="n">Dx_knn</span><span class="p">,</span> <span class="n">Dy_knn</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">log_cost</span><span class="p">))</span>

<span class="p">(</span><span class="n">pi_samp_lg</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="n">_</span><span class="p">,</span> <span class="n">log_cost</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">scootr</span><span class="o">.</span><span class="n">solver_fgw</span><span class="p">(</span><span class="n">Dx_knn</span><span class="p">,</span> <span class="n">Dy_knn</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">log_cost</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>20
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>5
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2
</pre></div>
</div>
</div>
</div>
<p>Note the decreasing length of the cost log. The longer cost logs for higher <span class="math notranslate nohighlight">\(\epsilon\)</span> indicate that more iterations were required for convergence to an optimal coupling matrix. This result indicates that larger values of <span class="math notranslate nohighlight">\(\epsilon\)</span> do help with faster convergence. Now, let’s align the data and examine the FOSCTTM scores for each alignment:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">aligned_y_sm</span> <span class="o">=</span> <span class="n">scootr</span><span class="o">.</span><span class="n">get_barycentre</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">pi_samp_sm</span><span class="p">)</span>
<span class="n">aligned_y_med</span> <span class="o">=</span> <span class="n">scootr</span><span class="o">.</span><span class="n">get_barycentre</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">pi_samp_med</span><span class="p">)</span>
<span class="n">aligned_y_lg</span> <span class="o">=</span> <span class="n">scootr</span><span class="o">.</span><span class="n">get_barycentre</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">pi_samp_lg</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">aligned_y</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">aligned_y_sm</span><span class="p">,</span> <span class="s1">&#39;eps=1e-5&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">aligned_y_med</span><span class="p">,</span> <span class="s1">&#39;eps=1e-3&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">aligned_y_lg</span><span class="p">,</span> <span class="s1">&#39;eps=1e-1&#39;</span><span class="p">)]:</span>
    <span class="n">fracs</span> <span class="o">=</span> <span class="n">scootr</span><span class="o">.</span><span class="n">calc_domainAveraged_FOSCTTM</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">aligned_y</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Average FOSCTTM score for this alignment (</span><span class="si">{0}</span><span class="s2">) with X onto Y is:&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">fracs</span><span class="p">))</span>
    <span class="n">legend_label</span><span class="o">=</span><span class="s2">&quot;UGW alignment FOSCTTM </span><span class="se">\n</span><span class="s2"> average value for </span><span class="si">{0}</span><span class="s2">: &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">size</span><span class="p">)</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">fracs</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fracs</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">fracs</span><span class="p">),</span> <span class="s2">&quot;b--&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">legend_label</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Cells&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Sorted FOSCTTM&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Average FOSCTTM score for this alignment (eps=1e-5) with X onto Y is: 0.5090595595595596
</pre></div>
</div>
<img alt="_images/c90e34d74c9718f161b3d4e58d8f2b3b29b36f4c72e0940358da85a4c518a7c8.png" src="_images/c90e34d74c9718f161b3d4e58d8f2b3b29b36f4c72e0940358da85a4c518a7c8.png" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Average FOSCTTM score for this alignment (eps=1e-3) with X onto Y is: 0.5489309309309309
</pre></div>
</div>
<img alt="_images/c826a0daf9ada0d93fff5ddcbbded29f5d3b79df06651ae2393241797837c47b.png" src="_images/c826a0daf9ada0d93fff5ddcbbded29f5d3b79df06651ae2393241797837c47b.png" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Average FOSCTTM score for this alignment (eps=1e-1) with X onto Y is: 0.41506306306306306
</pre></div>
</div>
<img alt="_images/97854d4e1ec1edebd6b47907890f7af55d4ac468419677799dbe2bd092c68d20.png" src="_images/97854d4e1ec1edebd6b47907890f7af55d4ac468419677799dbe2bd092c68d20.png" />
</div>
</div>
<p>Note that a smaller value of <span class="math notranslate nohighlight">\(\epsilon\)</span> does not necessarily guarantee better alignment quality. In fact, since smaller <span class="math notranslate nohighlight">\(\epsilon\)</span> encourages sparsity, it could lead to the sparsity pitfalls (confidently incorrect matchings) we looked at earlier in this section. To find the <span class="math notranslate nohighlight">\(\epsilon\)</span> best for your particular data, you can do a search of a given log space:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># an example of epsilon search</span>
<span class="n">pi_samp_dt</span> <span class="o">=</span> <span class="p">{}</span>
<span class="c1"># for val in np.logspace(start=-6, stop=-1, num=10):</span>
    <span class="c1"># (pi_samp_dt[val], _), _ = scootr.solver_fgw(Dx_knn, Dy_knn, eps=val)</span>
</pre></div>
</div>
</div>
</div>
<p>From here, we will continue our investigation of <span class="math notranslate nohighlight">\(\epsilon\)</span> by visualizing the data. We will start with the three coupling matrices.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">pi_samp</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">pi_samp_sm</span><span class="p">,</span> <span class="s1">&#39;eps=1e-5&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">pi_samp_med</span><span class="p">,</span> <span class="s1">&#39;eps=1e-3&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">pi_samp_lg</span><span class="p">,</span> <span class="s1">&#39;eps=1e-1&#39;</span><span class="p">)]:</span>    
    <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">pi_samp</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;Blues&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/e9a9964b31694c1a079f63b6b6357d5156c9bf69544b19a7baef13e40c2fa34f.png" src="_images/e9a9964b31694c1a079f63b6b6357d5156c9bf69544b19a7baef13e40c2fa34f.png" />
<img alt="_images/809925d938b27dba56a52ed2ea1c863e2e8d3af7644f8641e31658638f161d27.png" src="_images/809925d938b27dba56a52ed2ea1c863e2e8d3af7644f8641e31658638f161d27.png" />
<img alt="_images/952742b9cd1c1ab80f4389ef9c2f45937632192540dfb2b54da03fb3f67d32d3.png" src="_images/952742b9cd1c1ab80f4389ef9c2f45937632192540dfb2b54da03fb3f67d32d3.png" />
</div>
</div>
<p>Note how, for the larger value of <span class="math notranslate nohighlight">\(\epsilon\)</span>, we get a much more dense coupling matrix. This result is as we expected: larger <span class="math notranslate nohighlight">\(\epsilon\)</span> places a larger emphasis on entropy in our cost function. Let’s see what these different coupling matrices mean for our UMAP visualization:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">aligned_y</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">aligned_y_sm</span><span class="p">,</span> <span class="s1">&#39;eps=1e-5&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">aligned_y_med</span><span class="p">,</span> <span class="s1">&#39;eps=1e-3&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">aligned_y_lg</span><span class="p">,</span> <span class="s1">&#39;eps=1e-1&#39;</span><span class="p">)]:</span>    
    <span class="n">Xy_um</span><span class="o">=</span><span class="n">um</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">aligned_y</span><span class="o">.</span><span class="n">numpy</span><span class="p">()),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

    <span class="n">X_um</span><span class="o">=</span><span class="n">Xy_um</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1000</span><span class="p">,]</span>
    <span class="n">y_um</span><span class="o">=</span><span class="n">Xy_um</span><span class="p">[</span><span class="mi">1000</span><span class="p">:,]</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X_um</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">X_um</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;ADT&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">y_um</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">y_um</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Gene Expression&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Colored based on domains, </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/b6474ab2bfc7c9b06168b8753d7d00656e6577b6f75e2dc854f56bd89e7b8c7a.png" src="_images/b6474ab2bfc7c9b06168b8753d7d00656e6577b6f75e2dc854f56bd89e7b8c7a.png" />
<img alt="_images/2190f8aa5e3eec9958c39fa3197f3a71f345a93120e3767bce4125bd945faf8a.png" src="_images/2190f8aa5e3eec9958c39fa3197f3a71f345a93120e3767bce4125bd945faf8a.png" />
<img alt="_images/92508385e8438f2073cf43be4b0e80903065a39f18568c3cf2529587c7e46e50.png" src="_images/92508385e8438f2073cf43be4b0e80903065a39f18568c3cf2529587c7e46e50.png" />
</div>
</div>
<p>In the low <span class="math notranslate nohighlight">\(\epsilon\)</span> case, we see a near 1-1 alignment (remember, this near 1-1 is likely mapping wrong cells to wrong cells in many cases) in UMAP, which is consistent with the sparse coupling matrix. As we raise <span class="math notranslate nohighlight">\(\epsilon\)</span> to the medium case, we start to see some deviation from 1-1 alignment, and in the large <span class="math notranslate nohighlight">\(\epsilon\)</span> case, we see something completely different. To see what is really happening in this large <span class="math notranslate nohighlight">\(\epsilon\)</span> case, let’s try linear dimensionality reduction:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pca</span><span class="o">=</span><span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Xy_pca</span><span class="o">=</span><span class="n">pca</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">aligned_y_lg</span><span class="o">.</span><span class="n">numpy</span><span class="p">()),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
<span class="n">X_pca</span><span class="o">=</span><span class="n">Xy_pca</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1000</span><span class="p">,]</span>
<span class="n">y_pca</span><span class="o">=</span><span class="n">Xy_pca</span><span class="p">[</span><span class="mi">1000</span><span class="p">:,]</span>

<span class="c1"># Plot aligned domains, samples colored by domain identity:</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X_pca</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">X_pca</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;ADT&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">y_pca</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">y_pca</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Gene Expression&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Colored based on domains&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/1b65e5d6170e0ff6594ebc96ae9c23b2a70d65ec55bd77de1b323123ceffb5ad.png" src="_images/1b65e5d6170e0ff6594ebc96ae9c23b2a70d65ec55bd77de1b323123ceffb5ad.png" />
</div>
</div>
<p>As we can see, the projected data has little to no variance with respect to the principal components of our anchor domain. We can interpret this to mean that every point in the domain being projected was projected to an average of every point in the anchor domain; since the coupling matrix was so dense, projection just led to a weighted average of points where the weights were much closer to even. So, <span class="math notranslate nohighlight">\(\epsilon\)</span> too high and too low both have their setbacks.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Note that the <span class="math notranslate nohighlight">\(\epsilon\)</span> that produces the best alignment scores on co-assayed data like this will not necessarily generalize to separate assay data; finding a good <span class="math notranslate nohighlight">\(\epsilon\)</span> will vary case by case.</p>
</div>
<p>We can also demonstrate that the “entropic_mode” parameter doesn’t matter for UGW; the distinction between ‘joint’ and ‘independent’ comes in when we are hoping to regularize coupling matrices separately, which is not the case for UGW (where we expect our coupling matrices to be similar upon convergence). See our UCOOT tutorial for more detail on this parameter. See the following for an example of how they do not differ:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">pi_samp_ind</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="n">_</span> <span class="o">=</span> <span class="n">scootr</span><span class="o">.</span><span class="n">solver_fugw_simple</span><span class="p">(</span><span class="n">Dx_knn</span><span class="p">,</span> <span class="n">Dy_knn</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">entropic_mode</span><span class="o">=</span><span class="s2">&quot;independent&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="n">pi_samp_jnt</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="n">_</span> <span class="o">=</span> <span class="n">scootr</span><span class="o">.</span><span class="n">solver_fugw_simple</span><span class="p">(</span><span class="n">Dx_knn</span><span class="p">,</span> <span class="n">Dy_knn</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">entropic_mode</span><span class="o">=</span><span class="s2">&quot;joint&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">differs</span> <span class="o">=</span> <span class="kc">False</span>
<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">pi_samp_ind</span> <span class="o">==</span> <span class="n">pi_samp_jnt</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">row</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="n">differs</span> <span class="o">=</span> <span class="kc">True</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Are the matrices the same? </span><span class="si">{0}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">differs</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Are the matrices the same? True.
</pre></div>
</div>
</div>
</div>
<p>Now, we will move onto a different hyperparameter. The key takeaway from this section is that increasing <span class="math notranslate nohighlight">\(\epsilon\)</span> trades higher speed for less sparsity.</p>
</section>
<section id="marginal-relaxation">
<h2>Marginal Relaxation<a class="headerlink" href="#marginal-relaxation" title="Permalink to this heading">#</a></h2>
<p>With a general understanding of what <span class="math notranslate nohighlight">\(\epsilon\)</span> is doing, let’s now examine the <span class="math notranslate nohighlight">\(\rho\)</span> hyperparameter. As an argument to the UGW solver, <span class="math notranslate nohighlight">\(\rho\)</span> will be a tuple of two values; <span class="math notranslate nohighlight">\(\rho_x\)</span> relates to the samples in X, while <span class="math notranslate nohighlight">\(\rho_y\)</span> relates to the samples in y. Recall that UGW treats the samples in both domains as probability distributions and decides how to move mass from one distribution to the other, producing a coupling matrix. <span class="math notranslate nohighlight">\(\rho_x\)</span> and <span class="math notranslate nohighlight">\(\rho_y\)</span> determine how close the coupling matrix sticks to these distributions; they determine, in some sense, how close the marginals of the coupling distribution will be to these original distributions.</p>
<p>Specifically, <span class="math notranslate nohighlight">\(\rho_x\)</span> and <span class="math notranslate nohighlight">\(\rho_y\)</span> are multiplied by respective terms that measure (in terms of KL divergence) how close the desired distribution is to the marginals of the coupling matrix. So, the larger either <span class="math notranslate nohighlight">\(\rho\)</span> is, the closer its respective desired distribution will be to the marginals of the coupling matrix, as there will be a higher cost to differences between the distributions. In fact, we used <span class="math notranslate nohighlight">\(\rho\)</span> = infty in the previous examples; this forces the marginals of the coupling matrix to exactly match the desired distributions (otherwise incurring a cost of infinity). Allowing <span class="math notranslate nohighlight">\(\rho\)</span> to decrease below infinity leads to what we might call an “unbalancing” in the initial distributions, as we allow some samples to transport more or less mass than they were originally allocated. This is why we now use fugw instead of fgw – the u stands for unbalanced. Let’s look at how fugw works, first on a fairly balanced set of data:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">pi_samp</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="n">duals</span> <span class="o">=</span> <span class="n">scootr</span><span class="o">.</span><span class="n">solver_fugw_simple</span><span class="p">(</span><span class="n">Dx_knn</span><span class="p">,</span> <span class="n">Dy_knn</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">))</span>
<span class="n">aligned_y</span> <span class="o">=</span> <span class="n">scootr</span><span class="o">.</span><span class="n">get_barycentre</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">pi_samp</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We can start by scoring this alignment:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fracs</span> <span class="o">=</span> <span class="n">scootr</span><span class="o">.</span><span class="n">calc_domainAveraged_FOSCTTM</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">aligned_y</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Average FOSCTTM score for this alignment with X onto Y is:&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">fracs</span><span class="p">))</span>
<span class="n">legend_label</span><span class="o">=</span><span class="s2">&quot;UGW alignment FOSCTTM </span><span class="se">\n</span><span class="s2"> average value: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">fracs</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fracs</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">fracs</span><span class="p">),</span> <span class="s2">&quot;b--&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">legend_label</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Cells&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Sorted FOSCTTM&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Average FOSCTTM score for this alignment with X onto Y is: 0.5579354354354354
</pre></div>
</div>
<img alt="_images/19605ee174f431a501594f8d5a2b838e46e704a83270ef61e19b2bccc2052ba4.png" src="_images/19605ee174f431a501594f8d5a2b838e46e704a83270ef61e19b2bccc2052ba4.png" />
</div>
</div>
<p>And visualizing it:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Xy_um</span><span class="o">=</span><span class="n">um</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">aligned_y</span><span class="o">.</span><span class="n">numpy</span><span class="p">()),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

<span class="n">X_um</span><span class="o">=</span><span class="n">Xy_um</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1000</span><span class="p">,]</span>
<span class="n">y_um</span><span class="o">=</span><span class="n">Xy_um</span><span class="p">[</span><span class="mi">1000</span><span class="p">:,]</span>

<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X_um</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">X_um</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;ADT&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">y_um</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">y_um</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Gene Expression&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Colored based on domains&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/2f20c514f53b03117d274f9e4c76d83636435e81d340b4a60fb04ffe5562788d.png" src="_images/2f20c514f53b03117d274f9e4c76d83636435e81d340b4a60fb04ffe5562788d.png" />
</div>
</div>
<p>However, we can only truly get a window into <span class="math notranslate nohighlight">\(\rho\)</span> by looking at the coupling matrix. In the uniform marginal case, which we got with fgw, each row would have the same sum, <span class="math notranslate nohighlight">\(\frac{1}{1000}\)</span>. With our new unbalancing, this is no longer the case:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Unbalanced coupling matrix: &#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">pi_samp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Balanced coupling matrix: &#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">pi_samp_ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="c1"># a coupling matrix from earlier, that was balanced</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Unbalanced coupling matrix: 
tensor(0.0010)
tensor(0.0010)
tensor(0.0009)
tensor(0.0010)
tensor(0.0010)
tensor(0.0009)
tensor(0.0009)
tensor(0.0010)
tensor(0.0010)
tensor(0.0010)

Balanced coupling matrix: 
tensor(0.0010)
tensor(0.0010)
tensor(0.0010)
tensor(0.0010)
tensor(0.0010)
tensor(0.0010)
tensor(0.0010)
tensor(0.0010)
tensor(0.0010)
tensor(0.0010)
</pre></div>
</div>
</div>
</div>
<p>In our case, where we have 1000 cells without disproportionate cell type representation across domains, unbalancing these distributions doesn’t make much sense. However, if we were to have 50 cells of cell type 1 and 950 of cell type 2 in domain 1, and 500 of each in domain 2, we would want those 50 cells in domain 1 to transport much more mass. By allowing this to happen, <span class="math notranslate nohighlight">\(\rho\)</span> makes UGW much more robust to outliers and underrepresented cell types. Note that this disproportionate example would only really happen with separately assayed datasets.</p>
<p>Let’s see how unbalancing can help by taking 90 cells from smaller clusters in the above data and 10 cells from a larger cluster. We would expect these 10 cells to transport more mass with <span class="math notranslate nohighlight">\(\rho\)</span> &lt; infinity. We can begin by isolating one large cluster in the data, which we found by searching over k (and settling on k = 7) using a kneighbors graph.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">kneighbors_graph</span>
<span class="kn">from</span> <span class="nn">scipy.sparse.csgraph</span> <span class="kn">import</span> <span class="n">connected_components</span>

<span class="n">y_graph</span> <span class="o">=</span> <span class="n">kneighbors_graph</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;connectivity&#39;</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;correlation&#39;</span><span class="p">,</span> <span class="n">include_self</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">k</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">connected_components</span><span class="p">(</span><span class="n">y_graph</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">labels</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span class="n">labels</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0    825
1     52
4     31
2     22
3     18
6     15
8     15
7     13
5      9
Name: count, dtype: int64
</pre></div>
</div>
</div>
</div>
<p>As we can see, k = 7 gives us 9 different connected clusters on the k neighbors graph. We will treat the 0 labelled cluster as our large cluster, and sample 10 from that pool; we will treat the rest as smaller clusters, and sample 90:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sm_clust</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">labels</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">lg_clust</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">labels</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>

<span class="n">sm_clust_smpl</span> <span class="o">=</span> <span class="n">sm_clust</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">lg_clust_smpl</span> <span class="o">=</span> <span class="n">lg_clust</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="n">y_sm</span> <span class="o">=</span> <span class="n">y_annotated</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">sm_clust_smpl</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
<span class="n">y_lg</span> <span class="o">=</span> <span class="n">y_annotated</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">lg_clust_smpl</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>

<span class="n">in_clust_vec_sm</span> <span class="o">=</span> <span class="p">(</span><span class="n">labels</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">sm_clust_smpl</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
<span class="n">in_clust_vec_sm</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">y_sm</span><span class="o">.</span><span class="n">index</span>
<span class="n">in_clust_vec_sm</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Cluster&#39;</span>

<span class="n">in_clust_vec_lg</span> <span class="o">=</span> <span class="p">(</span><span class="n">labels</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">lg_clust_smpl</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
<span class="n">in_clust_vec_lg</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">y_lg</span><span class="o">.</span><span class="n">index</span>
<span class="n">in_clust_vec_lg</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Cluster&#39;</span>

<span class="n">y_sm</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="n">y_sm</span><span class="p">,</span> <span class="n">in_clust_vec_sm</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">y_lg</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="n">y_lg</span><span class="p">,</span> <span class="n">in_clust_vec_lg</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="n">y_new</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="n">y_lg</span><span class="p">,</span> <span class="n">y_sm</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>This process has given us a new version of our gene expression domain, which we will align with our original ADT domain. We expect that the top ten rows of the coupling matrix will transport more mass with <span class="math notranslate nohighlight">\(\rho\)</span> &lt; infty. Now, we can try an alignment; however, we first need a distance matrix for our new y:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%capture</span>
<span class="n">Dy_knn_new</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">scootr</span><span class="o">.</span><span class="n">knn_dist</span><span class="p">(</span><span class="n">y_new</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Now, we can align:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">pi_samp_u</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="n">duals</span> <span class="o">=</span> <span class="n">scootr</span><span class="o">.</span><span class="n">solver_fugw_simple</span><span class="p">(</span><span class="n">Dx_knn</span><span class="p">,</span> <span class="n">Dy_knn_new</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">))</span>
<span class="p">(</span><span class="n">pi_samp_ctrl</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="n">duals</span> <span class="o">=</span> <span class="n">scootr</span><span class="o">.</span><span class="n">solver_fugw_simple</span><span class="p">(</span><span class="n">Dx_knn</span><span class="p">,</span> <span class="n">Dy_knn_new</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)))</span>
</pre></div>
</div>
</div>
</div>
<p>From here, we can examine the coupling matrices – we care less about alignment quality and scoring, considering we now have an unbalanced case. First, let’s look at a heatmap:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">pi_samp</span> <span class="ow">in</span> <span class="n">pi_samp_u</span><span class="p">,</span> <span class="n">pi_samp_ctrl</span><span class="p">:</span>
    <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">pi_samp</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;Blues&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/666f21d826dd1d091084cedd85f63cd92009ef5b826d7d9d290a6108c85a8596.png" src="_images/666f21d826dd1d091084cedd85f63cd92009ef5b826d7d9d290a6108c85a8596.png" />
<img alt="_images/9712cc120cf98698a6a49672f8e2f9d9d12c3f9647bf588cc92cb20850e8fd22.png" src="_images/9712cc120cf98698a6a49672f8e2f9d9d12c3f9647bf588cc92cb20850e8fd22.png" />
</div>
</div>
<p>This visualization is not so easy to grasp; however, if we look at the column-wise sums, we can see exactly how unbalanced it is:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">sum</span><span class="p">(</span><span class="n">pi_samp_ctrl</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([0.01000202, 0.01000229, 0.01000199, 0.01000137, 0.01000188,
       0.01000179, 0.01000226, 0.01000216, 0.01000106, 0.01000112,
       0.01000214, 0.00999917, 0.00999715, 0.01000056, 0.01000054,
       0.00999736, 0.01000105, 0.00999898, 0.0099991 , 0.01000051,
       0.00999858, 0.00999922, 0.01000196, 0.00999686, 0.01000072,
       0.00999813, 0.01000243, 0.00999734, 0.01000053, 0.00999897,
       0.01000222, 0.01000061, 0.00999703, 0.00999891, 0.009997  ,
       0.01000048, 0.01000076, 0.01000032, 0.00999734, 0.00999875,
       0.01000056, 0.01000176, 0.01000032, 0.01000252, 0.01000105,
       0.01000237, 0.00999911, 0.01000124, 0.01000046, 0.01000078,
       0.00999686, 0.00999705, 0.00999928, 0.01000098, 0.01000046,
       0.01000225, 0.01000075, 0.01000159, 0.00999897, 0.01000004,
       0.01000047, 0.01000052, 0.0099993 , 0.01000041, 0.00999924,
       0.00999897, 0.01000062, 0.00999912, 0.00999904, 0.00999889,
       0.00999688, 0.01000206, 0.01000057, 0.00999881, 0.01000056,
       0.01000142, 0.01000231, 0.00999879, 0.01000132, 0.01000059,
       0.01000041, 0.01000042, 0.00999695, 0.00999717, 0.01000056,
       0.00999718, 0.00999897, 0.00999907, 0.00999931, 0.00999867,
       0.01000098, 0.01000059, 0.01000208, 0.01000092, 0.00999701,
       0.00999883, 0.00999947, 0.0100006 , 0.00999715, 0.0099991 ],
      dtype=float32)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">sum</span><span class="p">(</span><span class="n">pi_samp_u</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>tensor([0.0082, 0.0082, 0.0082, 0.0090, 0.0082, 0.0112, 0.0082, 0.0082, 0.0093,
        0.0096, 0.0098, 0.0115, 0.0076, 0.0099, 0.0104, 0.0061, 0.0082, 0.0060,
        0.0068, 0.0112, 0.0080, 0.0114, 0.0097, 0.0051, 0.0097, 0.0079, 0.0072,
        0.0062, 0.0108, 0.0081, 0.0098, 0.0114, 0.0063, 0.0060, 0.0076, 0.0106,
        0.0083, 0.0120, 0.0080, 0.0078, 0.0101, 0.0097, 0.0095, 0.0072, 0.0082,
        0.0072, 0.0057, 0.0081, 0.0108, 0.0088, 0.0055, 0.0055, 0.0115, 0.0080,
        0.0094, 0.0072, 0.0108, 0.0110, 0.0068, 0.0129, 0.0112, 0.0123, 0.0125,
        0.0106, 0.0098, 0.0063, 0.0107, 0.0103, 0.0109, 0.0103, 0.0055, 0.0098,
        0.0099, 0.0065, 0.0103, 0.0082, 0.0072, 0.0066, 0.0083, 0.0096, 0.0117,
        0.0120, 0.0055, 0.0074, 0.0110, 0.0081, 0.0116, 0.0113, 0.0114, 0.0104,
        0.0084, 0.0120, 0.0098, 0.0096, 0.0055, 0.0103, 0.0093, 0.0120, 0.0074,
        0.0113])
</pre></div>
</div>
</div>
</div>
<p>As we can see above, the first ten columns in the coupling matrix have larger sums than the others, meaning they are transporting more mass – this outcome is what we predicted! We can conclude that <span class="math notranslate nohighlight">\(\rho\)</span> is particularly helpful in cases where we have disproportionate representation of a particular subset (or subsets) of the underlying manifold shared between the two domains.</p>
</section>
<section id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this heading">#</a></h2>
<p>With an understanding of what <span class="math notranslate nohighlight">\(\rho\)</span> is doing, we still have one parameter left: uot_mode. UOT mode determines how we solve the problem of optimizing the coupling matrix; we have been using Sinkhorn’s algorithm (uot_mode=entropic) throughout this tutorial, but we also give the option to use the Majorization-Minimization algorithm (uot_mode=mm). In SCOOTR, we give additional options, like conditional gradient descent and earth mover’s distance. To read more on this topic, see the end of the UCOOT tutorial, where we do some experiments with this mode, or the SCOOTR tutorial, where we go into other available algorithms.</p>
<p>Now that we have gone through all of the most important pieces of how to run UGW on your own data, you can move onto our fused formulation or UCOOT tutorial. The fused formulation helps incorporate prior knowledge into the UGW/UCOOT procedures.</p>
<p>Citations:</p>
<p>Quang Huy Tran, Hicham Janati, Nicolas Courty, Rémi Flamary, Ievgen Redko, Pinar Demetci and Ritambhara Singh. Unbalanced CO-Optimal Transport. arXiv, <a class="reference external" href="http://stat.ML">stat.ML</a>, 2023.</p>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="setup_tutorial.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Setup Tutorial</p>
      </div>
    </a>
    <a class="right-next"
       href="UCOOT_tutorial.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">UCOOT Tutorial</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#data-download">Data download</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#preprocessing">Preprocessing</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#converting-datasets-to-distance-matrices">Converting Datasets to Distance Matrices</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#default-ugw">Default UGW</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#entropic-regularization">Entropic Regularization</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#marginal-relaxation">Marginal Relaxation</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#conclusion">Conclusion</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By R. Singh
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2022.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>